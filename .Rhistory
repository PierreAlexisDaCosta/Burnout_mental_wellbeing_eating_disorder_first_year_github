Reponse_EBE_P1_pre_filtered <-
readxl::read_excel("./Raw_data/Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1_pre_filtered
df <-
readxl::read_excel("./Raw_data/Survey_result.xlsx")
fake_df <- as.data.frame(lapply(df, sample))
fake_df
View(fake_df)
write_xlsx(fake_df, "Fake_Survey_FullyShuffled.xlsx")
writexl::write_xlsx(fake_df, "Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1_pre_filtered <-
readxl::read_excel("./Raw_data/Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1_pre_filtered <-
readxl::read_excel("./Raw_data/Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1_pre_filtered
library(readxl)
library(writexl)
library(tidyr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(gtsummary)
Correspondance_EBEP1_2025 <-
readxl::read_excel("./Raw_data/Correspondance_EBEP1_2025.xlsx")
Recode_of_every_possible_answer <-
readxl::read_excel("./Raw_data/Recode_of_every_possible_answer.xlsx")
Reponse_EBE_P1_pre_filtered <-
readxl::read_excel("./Raw_data/Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1 <-
Reponse_EBE_P1_pre_filtered[, (colnames(Reponse_EBE_P1_pre_filtered) %in%
Correspondance_EBEP1_2025$Nom)]
# Create a correspondence vector between names and codes
correspondance <- setNames(Correspondance_EBEP1_2025$Code, Correspondance_EBEP1_2025$Nom)
# Copy the original dataframe
Reponse_EBE_P1_recode <- Reponse_EBE_P1
# Replace column names if a match is found
colnames(Reponse_EBE_P1_recode) <- ifelse(
colnames(Reponse_EBE_P1_recode) %in% names(correspondance),
correspondance[colnames(Reponse_EBE_P1_recode)],
colnames(Reponse_EBE_P1_recode)  # laisser inchangé sinon
)
# Recoding function for a column
recode_2024 <- function(x) {
x <- as.character(x)  # in case it's numeric
x[x == "2024.0"] <- "2024"
return(x)
}
# Apply to the entire dataframe (e.g., Reponse_EBE_P1)
Reponse_EBE_P1_recode <- as.data.frame(lapply(Reponse_EBE_P1_recode, recode_2024), stringsAsFactors = FALSE)
# # Step 1: Get all unique answers from Reponse_EBE_P1
all_answers <- unique(unlist(Reponse_EBE_P1))
#
# # Step 2: Check which answers are NOT in the recode list
unknown_answers <- setdiff(all_answers, Recode_of_every_possible_answer$reponse_possible)
#
if(length(unknown_answers) > 0) {
cat("These answers have no recoding (not found in recode list):\n")
print(unknown_answers)
} else {
cat("All answers found in the recode list. Proceeding with recoding...\n")
}
# Step 3: Create a named vector for recoding for fast lookup
recode_vector <-
setNames(Recode_of_every_possible_answer$translation,
Recode_of_every_possible_answer$reponse_possible)
# Step 4: Replace answers by translation in the whole dataframe
# This will replace only known answers; unknown will become NA or stay same if you prefer
Reponse_EBE_P1_final <- as.data.frame(
lapply(Reponse_EBE_P1_recode, function(col) {
# Replace values by recode_vector if found, otherwise keep original or NA
recoded_col <- recode_vector[as.character(col)]
# Optional: keep original if not found
recoded_col[is.na(recoded_col)] <- as.character(col)[is.na(recoded_col)]
return(recoded_col)
}),
stringsAsFactors = FALSE
)
Reponse_EBE_P1_final <- as.data.frame(lapply(Reponse_EBE_P1_final, recode_2024), stringsAsFactors = FALSE) %>%
dplyr::rename(Financial_situation_concerns = Final_situation_concerns)
Reponse_EBE_P1 <-
Reponse_EBE_P1_pre_filtered[, (colnames(Reponse_EBE_P1_pre_filtered) %in%
Correspondance_EBEP1_2025$Nom)]
# Create a correspondence vector between names and codes
correspondance <- setNames(Correspondance_EBEP1_2025$Code, Correspondance_EBEP1_2025$Nom)
# Copy the original dataframe
Reponse_EBE_P1_recode <- Reponse_EBE_P1
# Replace column names if a match is found
colnames(Reponse_EBE_P1_recode) <- ifelse(
colnames(Reponse_EBE_P1_recode) %in% names(correspondance),
correspondance[colnames(Reponse_EBE_P1_recode)],
colnames(Reponse_EBE_P1_recode)  # laisser inchangé sinon
)
# Recoding function for a column
recode_2024 <- function(x) {
x <- as.character(x)  # in case it's numeric
x[x == "2024.0"] <- "2024"
return(x)
}
# Apply to the entire dataframe (e.g., Reponse_EBE_P1)
Reponse_EBE_P1_recode <- as.data.frame(lapply(Reponse_EBE_P1_recode, recode_2024), stringsAsFactors = FALSE)
# # Step 1: Get all unique answers from Reponse_EBE_P1
all_answers <- unique(unlist(Reponse_EBE_P1))
#
# # Step 2: Check which answers are NOT in the recode list
unknown_answers <- setdiff(all_answers, Recode_of_every_possible_answer$reponse_possible)
#
if(length(unknown_answers) > 0) {
cat("These answers have no recoding (not found in recode list):\n")
print(unknown_answers)
} else {
cat("All answers found in the recode list. Proceeding with recoding...\n")
}
# Step 3: Create a named vector for recoding for fast lookup
recode_vector <-
setNames(Recode_of_every_possible_answer$translation,
Recode_of_every_possible_answer$reponse_possible)
Reponse_EBE_P1_final <- as.data.frame(
lapply(Reponse_EBE_P1_recode, function(col) {
# Replace values by recode_vector if found, otherwise keep original or NA
recoded_col <- recode_vector[as.character(col)]
# Optional: keep original if not found
recoded_col[is.na(recoded_col)] <- as.character(col)[is.na(recoded_col)]
return(recoded_col)
}),
stringsAsFactors = FALSE
)
Reponse_EBE_P1_final <- as.data.frame(lapply(Reponse_EBE_P1_final, recode_2024), stringsAsFactors = FALSE) %>%
dplyr::rename(Financial_situation_concerns = Final_situation_concerns)
Reponse_EBE_P1_final
Reponse_EBE_P1_final <- as.data.frame(
lapply(Reponse_EBE_P1_recode, function(col) {
# Replace values by recode_vector if found, otherwise keep original or NA
recoded_col <- recode_vector[as.character(col)]
# Optional: keep original if not found
recoded_col[is.na(recoded_col)] <- as.character(col)[is.na(recoded_col)]
return(recoded_col)
}),
stringsAsFactors = FALSE
)
Reponse_EBE_P1_recode
Reponse_EBE_P1
Reponse_EBE_P1_pre_filtered
colnames(Reponse_EBE_P1_pre_filtered)
Reponse_EBE_P1 <-
Reponse_EBE_P1_pre_filtered[, (colnames(Reponse_EBE_P1_pre_filtered) %in%
Correspondance_EBEP1_2025$Nom)]
Reponse_EBE_P1 <-
Reponse_EBE_P1_pre_filtered[, (colnames(Reponse_EBE_P1_pre_filtered) %in%
Correspondance_EBEP1_2025$Nom)]
Reponse_EBE_P1
Reponse_EBE_P1_pre_filtered
Correspondance_EBEP1_2025$Nom
Correspondance_EBEP1_2025$Nom
colnames(Reponse_EBE_P1_pre_filtered
)
Reponse_EBE_P1_pre_filtered
Recode_of_every_possible_answer
df <-
readxl::read_excel("./Raw_data/Survey_result.xlsx")
df
fake_df <- as.data.frame(lapply(df, sample))
fake_df
df
df <-
readxl::read_excel("./Raw_data/Survey_result.xlsx")
df <-
readxl::read_excel("./Raw_data/Survey_result.xlsx")
df <-
readxl::read_excel("./Raw_data/Survey_result.xlsx")
df
View(df)
fake_df <- as.data.frame(lapply(df, sample))
fake_df
colnames(fake_df) <-
colnames(df)
fake_df
library(writexl)
writexl::write_xlsx(fake_df, "Fake_Survey_FullyShuffled.xlsx")
Correspondance_EBEP1_2025 <-
readxl::read_excel("./Raw_data/Correspondance_EBEP1_2025.xlsx")
Recode_of_every_possible_answer <-
readxl::read_excel("./Raw_data/Recode_of_every_possible_answer.xlsx")
Reponse_EBE_P1_pre_filtered <-
readxl::read_excel("./Raw_data/Fake_Survey_FullyShuffled.xlsx")
Reponse_EBE_P1 <-
Reponse_EBE_P1_pre_filtered[, (colnames(Reponse_EBE_P1_pre_filtered) %in%
Correspondance_EBEP1_2025$Nom)]
# Create a correspondence vector between names and codes
correspondance <- setNames(Correspondance_EBEP1_2025$Code, Correspondance_EBEP1_2025$Nom)
# Copy the original dataframe
Reponse_EBE_P1_recode <- Reponse_EBE_P1
# Replace column names if a match is found
colnames(Reponse_EBE_P1_recode) <- ifelse(
colnames(Reponse_EBE_P1_recode) %in% names(correspondance),
correspondance[colnames(Reponse_EBE_P1_recode)],
colnames(Reponse_EBE_P1_recode)  # laisser inchangé sinon
)
# Recoding function for a column
recode_2024 <- function(x) {
x <- as.character(x)  # in case it's numeric
x[x == "2024.0"] <- "2024"
return(x)
}
# Apply to the entire dataframe (e.g., Reponse_EBE_P1)
Reponse_EBE_P1_recode <- as.data.frame(lapply(Reponse_EBE_P1_recode, recode_2024), stringsAsFactors = FALSE)
# # Step 1: Get all unique answers from Reponse_EBE_P1
all_answers <- unique(unlist(Reponse_EBE_P1))
#
# # Step 2: Check which answers are NOT in the recode list
unknown_answers <- setdiff(all_answers, Recode_of_every_possible_answer$reponse_possible)
#
if(length(unknown_answers) > 0) {
cat("These answers have no recoding (not found in recode list):\n")
print(unknown_answers)
} else {
cat("All answers found in the recode list. Proceeding with recoding...\n")
}
# Step 3: Create a named vector for recoding for fast lookup
recode_vector <-
setNames(Recode_of_every_possible_answer$translation,
Recode_of_every_possible_answer$reponse_possible)
# Step 4: Replace answers by translation in the whole dataframe
# This will replace only known answers; unknown will become NA or stay same if you prefer
Reponse_EBE_P1_final <- as.data.frame(
lapply(Reponse_EBE_P1_recode, function(col) {
# Replace values by recode_vector if found, otherwise keep original or NA
recoded_col <- recode_vector[as.character(col)]
# Optional: keep original if not found
recoded_col[is.na(recoded_col)] <- as.character(col)[is.na(recoded_col)]
return(recoded_col)
}),
stringsAsFactors = FALSE
)
Reponse_EBE_P1_final <- as.data.frame(lapply(Reponse_EBE_P1_final, recode_2024), stringsAsFactors = FALSE) %>%
dplyr::rename(Financial_situation_concerns = Final_situation_concerns)
Reponse_EBE_P1_final %>%
writexl::write_xlsx("./Preprocessed_data/Reponse_EBE_P1_final.xlsx")
HAD_correspondance <-
Correspondance_EBEP1_2025 %>%
filter(Echelle == "HAD")
HAD_correspondance$Nom_anglais <-
str_remove_all(HAD_correspondance$Nom_anglais, "\\[|\\]")
HAD_correspondance$Nom_anglais <-
str_remove_all(HAD_correspondance$Nom_anglais, "HAD ")
HAD_correspondance$Nom_anglais <-
str_replace_all(HAD_correspondance$Nom_anglais, '"wound up"', 'wound up')
HAD_Reponse_EBE_P1_final <-
Reponse_EBE_P1_final %>%
select(contains("HAD"))
# Score Calcul ####
HAD_Reponse_EBE_P1_final_for_score <- HAD_Reponse_EBE_P1_final
# Plot HAD ####
# Retrieve the current column names
old_names <- colnames(HAD_Reponse_EBE_P1_final)
# Create a vector of new names, searching for matches in HAD_correspondance
new_names <- sapply(old_names, function(x) {
idx <- which(HAD_correspondance$Code == x)
if(length(idx) == 1) {
return(HAD_correspondance$Nom_anglais[idx])
} else {
# If there is no match, keep the original name.
return(x)
}
})
#Apply new names
colnames(HAD_Reponse_EBE_P1_final) <- new_names
HAD_Reponse_EBE_P1_final_long <- HAD_Reponse_EBE_P1_final %>%
pivot_longer(
cols = everything(),
names_to = "Question",
values_to = "Response"
)
HAD_Reponse_EBE_P1_final_summary <- HAD_Reponse_EBE_P1_final_long %>%
group_by(Question, Response) %>%
summarise(n = n(), .groups = "drop") %>%
group_by(Question) %>%
mutate(percent = n / sum(n))
# Force the order of terms
HAD_Reponse_EBE_P1_final_summary <- HAD_Reponse_EBE_P1_final_summary %>%
mutate(Response = factor(Response, levels = c("3 Most of the time", "2 Often", "1 From time to time", "0 Never")))
HAD_Reponse_EBE_P1_final_summary$Response %>% levels()
# Calculate the sum of 0 and 1 per question to bold if > 50%
bold_questions <- HAD_Reponse_EBE_P1_final_summary %>%
filter(Response %in% c("0 Never", "1 From time to time")) %>%
group_by(Question) %>%
summarise(sum_percent = sum(percent)) %>%
filter(sum_percent > 0.5) %>%
pull(Question)
# Add a column for bold or non-bold labels
HAD_Reponse_EBE_P1_final_summary <- HAD_Reponse_EBE_P1_final_summary %>%
mutate(bold_label = ifelse(Question %in% bold_questions, TRUE, FALSE))
# Prepare labels to display percentages in bars (rounded percentages)
HAD_Reponse_EBE_P1_final_summary <- HAD_Reponse_EBE_P1_final_summary %>%
mutate(percent_label = ifelse(percent > 0.02, paste0(round(percent*100), "%"), ""))  # n'affiche que si > 2%
# Define a gradient palette from light to dark blue (for example)
my_palette_HAD <- scales::gradient_n_pal(c("lightblue", "dodgerblue", "blue", "darkblue"))
# Generate 4 colors evenly spaced on the gradient
colors_HAD <- my_palette_HAD(seq(0, 1, length.out = 4))
ggplot(HAD_Reponse_EBE_P1_final_summary, aes(x = Question, y = percent, fill = Response)) +
geom_bar(stat = "identity", position = "fill") +
geom_text(aes(label = percent_label),
position = position_fill(vjust = 0.5),
color = "white",
size = 3) +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "black") +
coord_flip() +
scale_y_continuous(labels = scales::percent_format()) +
scale_fill_manual(values = colors_HAD) +
labs(title = "Distribution of HAD responses by question",
x = "Question",
y = "Percentage",
fill = "Response") +
theme_minimal()
